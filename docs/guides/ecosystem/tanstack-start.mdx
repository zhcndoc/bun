---
title: ä½¿ç”¨ Bun å¯åŠ¨ TanStack Start
sidebarTitle: ä½¿ç”¨ Bun å¯åŠ¨ TanStack Start
mode: center
---

[TanStack Start](https://tanstack.com/start/latest) æ˜¯ä¸€ä¸ªç”± TanStack Router é©±åŠ¨çš„å…¨æ ˆæ¡†æ¶ã€‚å®ƒæ”¯æŒå®Œæ•´æ–‡æ¡£çš„æœåŠ¡å™¨ç«¯æ¸²æŸ“ï¼ˆSSRï¼‰ã€æµå¼ä¼ è¾“ã€æœåŠ¡å™¨å‡½æ•°ã€æ‰“åŒ…ç­‰åŠŸèƒ½ï¼Œåº•å±‚ä¾èµ– TanStack Router å’Œ [Vite](https://vite.dev/)ã€‚

---

<Steps>
  <Step title="åˆ›å»ºä¸€ä¸ªæ–°çš„ TanStack Start åº”ç”¨">
    ä½¿ç”¨äº¤äº’å¼ CLI åˆ›å»ºä¸€ä¸ªæ–°çš„ TanStack Start åº”ç”¨ã€‚

    ```sh terminal icon="terminal"
    bun create @tanstack/start@latest my-tanstack-app
    ```

  </Step>
  <Step title="å¯åŠ¨å¼€å‘æœåŠ¡å™¨">
    åˆ‡æ¢åˆ°é¡¹ç›®ç›®å½•å¹¶ä½¿ç”¨ Bun å¯åŠ¨å¼€å‘æœåŠ¡å™¨ã€‚

    ```sh terminal icon="terminal"
    cd my-tanstack-app
    bun --bun run dev
    ```

    è¿™å°†å¯åŠ¨ç”± Bun è¿è¡Œçš„ Vite å¼€å‘æœåŠ¡å™¨ã€‚

  </Step>
  <Step title="æ›´æ–° package.json ä¸­çš„è„šæœ¬">
   ä¿®æ”¹ `package.json` ä¸­çš„ scripts å­—æ®µï¼Œåœ¨ Vite CLI å‘½ä»¤å‰æ·»åŠ  `bun --bun` å‰ç¼€ï¼Œä»¥ç¡®ä¿ Bun æ‰§è¡Œ Vite CLI æ¥å¤„ç†å¸¸è§ä»»åŠ¡ï¼Œå¦‚ `dev`ã€`build` å’Œ `preview`ã€‚

    ```json package.json icon="file-json"
    {
      "scripts": {
        "dev": "bun --bun vite dev", // [!code ++]
        "build": "bun --bun vite build", // [!code ++]
        "serve": "bun --bun vite preview" // [!code ++]
      }
    }
    ```

  </Step>
</Steps>

---

## éƒ¨ç½²æ‰˜ç®¡

è¦æ‰˜ç®¡ä½ çš„ TanStack Start åº”ç”¨ï¼Œå¯ä»¥ä½¿ç”¨ [Nitro](https://nitro.build/) æˆ–è‡ªå®šä¹‰ Bun æœåŠ¡å™¨è¿›è¡Œç”Ÿäº§ç¯å¢ƒéƒ¨ç½²ã€‚

<Tabs>
  <Tab title="Nitro">
    <Steps>
      <Step title="å°† Nitro æ·»åŠ åˆ°ä½ çš„é¡¹ç›®ä¸­">
        æ·»åŠ  [Nitro](https://nitro.build/) åˆ°ä½ çš„é¡¹ç›®ã€‚æ­¤å·¥å…·å…è®¸ä½ å°† TanStack Start åº”ç”¨éƒ¨ç½²åˆ°ä¸åŒçš„å¹³å°ã€‚

        ```sh terminal icon="terminal"
        bun add nitro
        ```

      </Step>
      <Step title={<span>æ›´æ–°ä½ çš„ <code>vite.config.ts</code> æ–‡ä»¶</span>}>
        æ›´æ–°ä½ çš„ `vite.config.ts` æ–‡ä»¶ï¼ŒåŠ å…¥ TanStack Start å’Œ Bun éœ€è¦çš„æ’ä»¶ã€‚

        ```ts vite.config.ts icon="/icons/typescript.svg"
        // å…¶ä»–å¯¼å…¥...
        import { nitro } from "nitro/vite"; // [!code ++]

        const config = defineConfig({
          plugins: [
            tanstackStart(),
            nitro({ preset: "bun" }), // [!code ++]
            // å…¶ä»–æ’ä»¶...
          ],
        });

        export default config;
        ```

        <Note>
          `bun` é¢„è®¾æ˜¯å¯é€‰çš„ï¼Œä½†å®ƒä¼šé’ˆå¯¹ Bun è¿è¡Œæ—¶ç‰¹åˆ«é…ç½®æ„å»ºè¾“å‡ºã€‚
        </Note>

      </Step>
      <Step title="æ›´æ–°å¯åŠ¨å‘½ä»¤">
        ç¡®ä¿ä½ çš„ `package.json` æ–‡ä»¶ä¸­åŒ…å« `build` å’Œ `start` è„šæœ¬ï¼š

        ```json package.json icon="file-json"
          {
            "scripts": {
              "build": "bun --bun vite build", // [!code ++]
              // å½“ä½ è¿è¡Œ `bun run build` æ—¶ï¼ŒNitro ä¼šåˆ›å»º .output æ–‡ä»¶å¤¹ã€‚
              // éƒ¨ç½²åˆ° Vercel æ—¶ä¸éœ€è¦æ­¤é…ç½®ã€‚
              "start": "bun run .output/server/index.mjs" // [!code ++]
            }
          }
        ```

        <Note>
          éƒ¨ç½²åˆ° Vercel æ—¶ï¼Œ**ä¸éœ€è¦** è‡ªå®šä¹‰çš„ `start` è„šæœ¬ã€‚
        </Note>

      </Step>
      <Step title="éƒ¨ç½²ä½ çš„åº”ç”¨">
        æŸ¥çœ‹æˆ‘ä»¬çš„éƒ¨ç½²æŒ‡å—ï¼Œå°†ä½ çš„åº”ç”¨éƒ¨ç½²åˆ°æ‰˜ç®¡æœåŠ¡å•†ã€‚

        <Note>
          éƒ¨ç½²åˆ° Vercel æ—¶ï¼Œå¯ä»¥åœ¨ `vercel.json` æ–‡ä»¶ä¸­æ·»åŠ  `"bunVersion": "1.x"`ï¼Œæˆ–è€…åœ¨ `vite.config.ts` ä¸­çš„ `nitro` é…ç½®é‡Œæ·»åŠ ï¼š

          <Warning>
            éƒ¨ç½²åˆ° Vercel æ—¶**ä¸è¦**ä½¿ç”¨ `bun` çš„ Nitro é¢„è®¾ã€‚
          </Warning>

          ```ts vite.config.ts icon="/icons/typescript.svg"
          export default defineConfig({
            plugins: [
              tanstackStart(),
              nitro({
                preset: "bun", // [!code --]
                vercel: { // [!code ++]
                  functions: { // [!code ++]
                    runtime: "bun1.x", // [!code ++]
                  }, // [!code ++]
              }, // [!code ++]
              }),
            ],
          });
          ```
        </Note>
      </Step>
    </Steps>

  </Tab>
  <Tab title="è‡ªå®šä¹‰æœåŠ¡å™¨">
    <Note>
      æ­¤è‡ªå®šä¹‰æœåŠ¡å™¨å®ç°åŸºäº [TanStack çš„ Bun æ¨¡æ¿](https://github.com/TanStack/router/blob/main/examples/react/start-bun/server.ts)ã€‚å®ƒæä¾›äº†å¯¹é™æ€èµ„æºæœåŠ¡çš„ç»†ç²’åº¦æ§åˆ¶ï¼ŒåŒ…æ‹¬æ”¯æŒå†…å­˜ç®¡ç†çš„é…ç½®ï¼Œå¯ä»¥å°†å°æ–‡ä»¶é¢„åŠ è½½åˆ°å†…å­˜ä¸­ä»¥å®ç°å¿«é€Ÿå“åº”ï¼Œè¾ƒå¤§çš„æ–‡ä»¶åˆ™æŒ‰éœ€ä»ç£ç›˜æä¾›ã€‚æ­¤æ–¹æ¡ˆåœ¨ç”Ÿäº§ç¯å¢ƒä¸­éœ€è¦ç²¾å‡†æ§åˆ¶èµ„æºä½¿ç”¨å’Œèµ„æºåŠ è½½è¡Œä¸ºæ—¶éå¸¸æœ‰ç”¨ã€‚
    </Note>

    <Steps>
      <Step title="åˆ›å»ºç”Ÿäº§æœåŠ¡å™¨">
        åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»ºä¸€ä¸ª `server.ts` æ–‡ä»¶ï¼Œå†…å®¹å¦‚ä¸‹ï¼ŒåŒ…å«äº†è‡ªå®šä¹‰æœåŠ¡å™¨çš„å®Œæ•´å®ç°ï¼š

        ```ts server.ts icon="/icons/typescript.svg" expandable
        /**
        * TanStack Start ç”Ÿäº§æœåŠ¡å™¨ï¼ˆåŸºäº Bunï¼‰
        *
        * ä¸€ä¸ªé«˜æ€§èƒ½çš„ TanStack Start ç”Ÿäº§æœåŠ¡å™¨ï¼Œå®ç°äº†æ™ºèƒ½çš„é™æ€èµ„æºåŠ è½½ç­–ç•¥ï¼Œæ”¯æŒå†…å­˜ç®¡ç†é…ç½®ã€‚
        *
        * åŠŸèƒ½:
        * - æ··åˆåŠ è½½ç­–ç•¥ï¼ˆé¢„åŠ è½½å°æ–‡ä»¶ï¼ŒæŒ‰éœ€æä¾›å¤§æ–‡ä»¶ï¼‰
        * - å¯é…ç½®çš„æ–‡ä»¶åŒ…å«/æ’é™¤è§„åˆ™
        * - å†…å­˜é«˜æ•ˆå“åº”ç”Ÿæˆ
        * - ç”Ÿäº§ç¯å¢ƒç¼“å­˜å¤´é…ç½®
        *
        * ç¯å¢ƒå˜é‡è¯´æ˜:
        *
        * PORT (number)
        *   - æœåŠ¡å™¨ç›‘å¬ç«¯å£
        *   - é»˜è®¤: 3000
        *
        * ASSET_PRELOAD_MAX_SIZE (number)
        *   - é¢„åŠ è½½åˆ°å†…å­˜çš„æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
        *   - è¶…å‡ºæ­¤å¤§å°çš„æ–‡ä»¶å°†æŒ‰éœ€ä»ç£ç›˜è¯»å–
        *   - é»˜è®¤: 5242880 (5MB)
        *   - ä¾‹å¦‚: ASSET_PRELOAD_MAX_SIZE=5242880 (5MB)
        *
        * ASSET_PRELOAD_INCLUDE_PATTERNS (string)
        *   - é€—å·åˆ†éš”çš„ glob æ¨¡å¼åˆ—è¡¨ï¼ŒæŒ‡å®šåŒ…å«çš„æ–‡ä»¶
        *   - å¦‚æœè®¾ç½®ï¼Œåªæœ‰åŒ¹é…çš„æ–‡ä»¶æ‰ä¼šè¢«é¢„åŠ è½½
        *   - åŒ¹é…æ–‡ä»¶åè€Œéå®Œæ•´è·¯å¾„
        *   - ä¾‹å¦‚: ASSET_PRELOAD_INCLUDE_PATTERNS="*.js,*.css,*.woff2"
        *
        * ASSET_PRELOAD_EXCLUDE_PATTERNS (string)
        *   - é€—å·åˆ†éš”çš„ glob æ¨¡å¼åˆ—è¡¨ï¼ŒæŒ‡å®šæ’é™¤çš„æ–‡ä»¶
        *   - åœ¨åŒ…å«è§„åˆ™ä¹‹ååº”ç”¨
        *   - åŒ¹é…æ–‡ä»¶åè€Œéå®Œæ•´è·¯å¾„
        *   - ä¾‹å¦‚: ASSET_PRELOAD_EXCLUDE_PATTERNS="*.map,*.txt"
        *
        * ASSET_PRELOAD_VERBOSE_LOGGING (boolean)
        *   - å¯ç”¨è¯¦ç»†æ–‡ä»¶åŠ è½½æ—¥å¿—
        *   - é»˜è®¤: false
        *   - è®¾ç½®ä¸º "true" å¯å¼€å¯è¯¦ç»†è¾“å‡º
        *
        * ASSET_PRELOAD_ENABLE_ETAG (boolean)
        *   - å¯ç”¨ ETag æ”¯æŒ
        *   - é»˜è®¤: true
        *   - è®¾ç½®ä¸º "false" ç¦ç”¨ ETag
        *
        * ASSET_PRELOAD_ENABLE_GZIP (boolean)
        *   - å¯ç”¨ Gzip å‹ç¼©
        *   - é»˜è®¤: true
        *   - è®¾ç½®ä¸º "false" ç¦ç”¨ Gzip
        *
        * ASSET_PRELOAD_GZIP_MIN_SIZE (number)
        *   - Gzip å‹ç¼©çš„æœ€å°æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
        *   - å°äºæ­¤å¤§å°ä¸å‹ç¼©
        *   - é»˜è®¤: 1024 (1KB)
        *
        * ASSET_PRELOAD_GZIP_MIME_TYPES (string)
        *   - æ”¯æŒ Gzip å‹ç¼©çš„ MIME ç±»å‹ï¼Œé€—å·åˆ†éš”
        *   - æ”¯æŒä»¥ "/" ç»“å°¾çš„éƒ¨åˆ†åŒ¹é…
        *   - é»˜è®¤: text/,application/javascript,application/json,application/xml,image/svg+xml
        *
        * å¯åŠ¨æ–¹å¼:
        *   bun run server.ts
        */

        import path from 'node:path'

        // é…ç½®éƒ¨åˆ†
        const SERVER_PORT = Number(process.env.PORT ?? 3000)
        const CLIENT_DIRECTORY = './dist/client'
        const SERVER_ENTRY_POINT = './dist/server/server.js'

        // ä¸“ä¸šæ—¥å¿—å·¥å…·
        const log = {
          info: (message: string) => {
            console.log(`[INFO] ${message}`)
          },
          success: (message: string) => {
            console.log(`[SUCCESS] ${message}`)
          },
          warning: (message: string) => {
            console.log(`[WARNING] ${message}`)
          },
          error: (message: string) => {
            console.log(`[ERROR] ${message}`)
          },
          header: (message: string) => {
            console.log(`\n${message}\n`)
          },
        }

        // é¢„åŠ è½½ç›¸å…³é…ç½®ï¼ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼‰
        const MAX_PRELOAD_BYTES = Number(
          process.env.ASSET_PRELOAD_MAX_SIZE ?? 5 * 1024 * 1024, // é»˜è®¤ 5MB
        )

        // è§£æåŒ…å«è§„åˆ™, æ— é»˜è®¤
        const INCLUDE_PATTERNS = (process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? '')
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean)
          .map((pattern: string) => convertGlobToRegExp(pattern))

        // è§£ææ’é™¤è§„åˆ™, æ— é»˜è®¤
        const EXCLUDE_PATTERNS = (process.env.ASSET_PRELOAD_EXCLUDE_PATTERNS ?? '')
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean)
          .map((pattern: string) => convertGlobToRegExp(pattern))

        // æ˜¯å¦å¼€å¯è¯¦ç»†æ—¥å¿—
        const VERBOSE = process.env.ASSET_PRELOAD_VERBOSE_LOGGING === 'true'

        // æ˜¯å¦å¯ç”¨ ETag
        const ENABLE_ETAG = (process.env.ASSET_PRELOAD_ENABLE_ETAG ?? 'true') === 'true'

        // æ˜¯å¦å¯ç”¨ gzip
        const ENABLE_GZIP = (process.env.ASSET_PRELOAD_ENABLE_GZIP ?? 'true') === 'true'
        const GZIP_MIN_BYTES = Number(process.env.ASSET_PRELOAD_GZIP_MIN_SIZE ?? 1024) // 1KB
        const GZIP_TYPES = (
          process.env.ASSET_PRELOAD_GZIP_MIME_TYPES ??
          'text/,application/javascript,application/json,application/xml,image/svg+xml'
        )
          .split(',')
          .map((v) => v.trim())
          .filter(Boolean)

        /**
        * å°†ç®€å•çš„ glob æ¨¡å¼è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼
        * æ”¯æŒ * é€šé…ç¬¦åŒ¹é…ä»»æ„å­—ç¬¦
        */
        function convertGlobToRegExp(globPattern: string): RegExp {
          // è½¬ä¹‰æ­£åˆ™ç‰¹æ®Šå­—ç¬¦ï¼Œé™¤äº† *, ç„¶åå°† * æ›¿æ¢ä¸º .*
          const escapedPattern = globPattern
            .replace(/[-/\\^$+?.()|[\]{}]/g, '\\$&')
            .replace(/\*/g, '.*')
          return new RegExp(`^${escapedPattern}$`, 'i')
        }

        /**
        * è®¡ç®—ç»™å®šæ•°æ®çš„ ETag å€¼
        */
        function computeEtag(data: Uint8Array): string {
          const hash = Bun.hash(data)
          return `W/"${hash.toString(16)}-${data.byteLength.toString()}"`
        }

        /**
        * é¢„åŠ è½½é™æ€èµ„æºçš„å…ƒæ•°æ®æ¥å£
        */
        interface AssetMetadata {
          route: string
          size: number
          type: string
        }

        /**
        * æ”¯æŒ ETag å’Œ Gzip çš„å†…å­˜èµ„æºæ¥å£
        */
        interface InMemoryAsset {
          raw: Uint8Array
          gz?: Uint8Array
          etag?: string
          type: string
          immutable: boolean
          size: number
        }

        /**
        * é¢„åŠ è½½ç»“æœæ¥å£
        */
        interface PreloadResult {
          routes: Record<string, (req: Request) => Response | Promise<Response>>
          loaded: AssetMetadata[]
          skipped: AssetMetadata[]
        }

        /**
        * åˆ¤æ–­æ–‡ä»¶æ˜¯å¦ç¬¦åˆé¢„åŠ è½½æ¡ä»¶
        */
        function isFileEligibleForPreloading(relativePath: string): boolean {
          const fileName = relativePath.split(/[/\\]/).pop() ?? relativePath

          // å¦‚æœæŒ‡å®šäº†åŒ…å«è§„åˆ™ï¼Œæ–‡ä»¶å¿…é¡»åŒ¹é…è‡³å°‘ä¸€ä¸ª
          if (INCLUDE_PATTERNS.length > 0) {
            if (!INCLUDE_PATTERNS.some((pattern) => pattern.test(fileName))) {
              return false
            }
          }

          // å¦‚æœæŒ‡å®šäº†æ’é™¤è§„åˆ™ï¼Œæ–‡ä»¶ä¸å¾—åŒ¹é…ä»»ä½•ä¸€ä¸ª
          if (EXCLUDE_PATTERNS.some((pattern) => pattern.test(fileName))) {
            return false
          }

          return true
        }

        /**
        * åˆ¤æ–­ MIME ç±»å‹æ˜¯å¦æ”¯æŒå‹ç¼©
        */
        function isMimeTypeCompressible(mimeType: string): boolean {
          return GZIP_TYPES.some((type) =>
            type.endsWith('/') ? mimeType.startsWith(type) : mimeType === type,
          )
        }

        /**
        * æ ¹æ®å¤§å°å’Œ MIME ç±»å‹å†³å®šæ˜¯å¦å‹ç¼©æ•°æ®
        */
        function compressDataIfAppropriate(
          data: Uint8Array,
          mimeType: string,
        ): Uint8Array | undefined {
          if (!ENABLE_GZIP) return undefined
          if (data.byteLength < GZIP_MIN_BYTES) return undefined
          if (!isMimeTypeCompressible(mimeType)) return undefined
          try {
            return Bun.gzipSync(data.buffer as ArrayBuffer)
          } catch {
            return undefined
          }
        }

        /**
        * åˆ›å»ºæ”¯æŒ ETag å’Œ Gzip çš„å“åº”å¤„ç†å‡½æ•°
        */
        function createResponseHandler(
          asset: InMemoryAsset,
        ): (req: Request) => Response {
          return (req: Request) => {
            const headers: Record<string, string> = {
              'Content-Type': asset.type,
              'Cache-Control': asset.immutable
                ? 'public, max-age=31536000, immutable'
                : 'public, max-age=3600',
            }

            if (ENABLE_ETAG && asset.etag) {
              const ifNone = req.headers.get('if-none-match')
              if (ifNone && ifNone === asset.etag) {
                return new Response(null, {
                  status: 304,
                  headers: { ETag: asset.etag },
                })
              }
              headers.ETag = asset.etag
            }

            if (
              ENABLE_GZIP &&
              asset.gz &&
              req.headers.get('accept-encoding')?.includes('gzip')
            ) {
              headers['Content-Encoding'] = 'gzip'
              headers['Content-Length'] = String(asset.gz.byteLength)
              const gzCopy = new Uint8Array(asset.gz)
              return new Response(gzCopy, { status: 200, headers })
            }

            headers['Content-Length'] = String(asset.raw.byteLength)
            const rawCopy = new Uint8Array(asset.raw)
            return new Response(rawCopy, { status: 200, headers })
          }
        }

        /**
        * åˆ›å»ºå¤åˆ glob æ¨¡å¼ï¼Œç”¨äºæ‰«ææ–‡ä»¶
        */
        function createCompositeGlobPattern(): Bun.Glob {
          const raw = (process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? '')
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
          if (raw.length === 0) return new Bun.Glob('**/*')
          if (raw.length === 1) return new Bun.Glob(raw[0])
          return new Bun.Glob(`{${raw.join(',')}}`)
        }

        /**
        * åˆå§‹åŒ–é™æ€è·¯ç”±ï¼Œæ™ºèƒ½é€‰æ‹©é¢„åŠ è½½ç­–ç•¥
        * å°æ–‡ä»¶åŠ è½½å…¥å†…å­˜ï¼Œè¾ƒå¤§æ–‡ä»¶æŒ‰éœ€åŠ è½½
        */
        async function initializeStaticRoutes(
          clientDirectory: string,
        ): Promise<PreloadResult> {
          const routes: Record<string, (req: Request) => Response | Promise<Response>> =
            {}
          const loaded: AssetMetadata[] = []
          const skipped: AssetMetadata[] = []

          log.info(`ä» ${clientDirectory} åŠ è½½é™æ€èµ„æº...`)
          if (VERBOSE) {
            console.log(
              `æœ€å¤§é¢„åŠ è½½æ–‡ä»¶å¤§å°ï¼š${(MAX_PRELOAD_BYTES / 1024 / 1024).toFixed(2)} MB`,
            )
            if (INCLUDE_PATTERNS.length > 0) {
              console.log(
                `åŒ…å«æ¨¡å¼ï¼š${process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? ''}`,
              )
            }
            if (EXCLUDE_PATTERNS.length > 0) {
              console.log(
                `æ’é™¤æ¨¡å¼ï¼š${process.env.ASSET_PRELOAD_EXCLUDE_PATTERNS ?? ''}`,
              )
            }
          }

          let totalPreloadedBytes = 0

          try {
            const glob = createCompositeGlobPattern()
            for await (const relativePath of glob.scan({ cwd: clientDirectory })) {
              const filepath = path.join(clientDirectory, relativePath)
              const route = `/${relativePath.split(path.sep).join(path.posix.sep)}`

              try {
                // è·å–æ–‡ä»¶å…ƒæ•°æ®
                const file = Bun.file(filepath)

                // æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©ºè·³è¿‡
                if (!(await file.exists()) || file.size === 0) {
                  continue
                }

                const metadata: AssetMetadata = {
                  route,
                  size: file.size,
                  type: file.type || 'application/octet-stream',
                }

                // åˆ¤æ–­æ–‡ä»¶æ˜¯å¦ç¬¦åˆé¢„åŠ è½½æ¡ä»¶
                const matchesPattern = isFileEligibleForPreloading(relativePath)
                const withinSizeLimit = file.size <= MAX_PRELOAD_BYTES

                if (matchesPattern && withinSizeLimit) {
                  // å°æ–‡ä»¶é¢„åŠ è½½åˆ°å†…å­˜ï¼Œæ”¯æŒ ETag å’Œ Gzip
                  const bytes = new Uint8Array(await file.arrayBuffer())
                  const gz = compressDataIfAppropriate(bytes, metadata.type)
                  const etag = ENABLE_ETAG ? computeEtag(bytes) : undefined
                  const asset: InMemoryAsset = {
                    raw: bytes,
                    gz,
                    etag,
                    type: metadata.type,
                    immutable: true,
                    size: bytes.byteLength,
                  }
                  routes[route] = createResponseHandler(asset)

                  loaded.push({ ...metadata, size: bytes.byteLength })
                  totalPreloadedBytes += bytes.byteLength
                } else {
                  // å¤§æ–‡ä»¶æˆ–è¿‡æ»¤çš„æ–‡ä»¶æŒ‰éœ€åŠ è½½
                  routes[route] = () => {
                    const fileOnDemand = Bun.file(filepath)
                    return new Response(fileOnDemand, {
                      headers: {
                        'Content-Type': metadata.type,
                        'Cache-Control': 'public, max-age=3600',
                      },
                    })
                  }

                  skipped.push(metadata)
                }
              } catch (error: unknown) {
                if (error instanceof Error && error.name !== 'EISDIR') {
                  log.error(`åŠ è½½æ–‡ä»¶å¤±è´¥ ${filepath}: ${error.message}`)
                }
              }
            }

            // åªæœ‰å¼€å¯è¯¦ç»†æ—¥å¿—æ—¶æ˜¾ç¤ºè¯¦ç»†æ–‡ä»¶åˆ—è¡¨
            if (VERBOSE && (loaded.length > 0 || skipped.length > 0)) {
              const allFiles = [...loaded, ...skipped].sort((a, b) =>
                a.route.localeCompare(b.route),
              )

              // è®¡ç®—æœ€å¤§è·¯å¾„é•¿åº¦ï¼Œæ–¹ä¾¿å¯¹é½
              const maxPathLength = Math.min(
                Math.max(...allFiles.map((f) => f.route.length)),
                60,
              )

              // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°ï¼ŒåŒ…å«å®é™… gzip å¤§å°
              const formatFileSize = (bytes: number, gzBytes?: number) => {
                const kb = bytes / 1024
                const sizeStr = kb < 100 ? kb.toFixed(2) : kb.toFixed(1)

                if (gzBytes !== undefined) {
                  const gzKb = gzBytes / 1024
                  const gzStr = gzKb < 100 ? gzKb.toFixed(2) : gzKb.toFixed(1)
                  return {
                    size: sizeStr,
                    gzip: gzStr,
                  }
                }

                // ç²—ç•¥çš„ gzip ä¼°ç®—ï¼ˆé€šå¸¸ 30%-70% å‹ç¼©ï¼‰
                const gzipKb = kb * 0.35
                return {
                  size: sizeStr,
                  gzip: gzipKb < 100 ? gzipKb.toFixed(2) : gzipKb.toFixed(1),
                }
              }

              if (loaded.length > 0) {
                console.log('\nğŸ“ é¢„åŠ è½½åˆ°å†…å­˜ä¸­çš„æ–‡ä»¶:')
                console.log(
                  'è·¯å¾„                                          â”‚    å¤§å° â”‚ Gzip å¤§å°',
                )
                loaded
                  .sort((a, b) => a.route.localeCompare(b.route))
                  .forEach((file) => {
                    const { size, gzip } = formatFileSize(file.size)
                    const paddedPath = file.route.padEnd(maxPathLength)
                    const sizeStr = `${size.padStart(7)} kB`
                    const gzipStr = `${gzip.padStart(7)} kB`
                    console.log(`${paddedPath} â”‚ ${sizeStr} â”‚  ${gzipStr}`)
                  })
              }

              if (skipped.length > 0) {
                console.log('\nğŸ’¾ æŒ‰éœ€æä¾›çš„æ–‡ä»¶:')
                console.log(
                  'è·¯å¾„                                          â”‚    å¤§å° â”‚ Gzip å¤§å°',
                )
                skipped
                  .sort((a, b) => a.route.localeCompare(b.route))
                  .forEach((file) => {
                    const { size, gzip } = formatFileSize(file.size)
                    const paddedPath = file.route.padEnd(maxPathLength)
                    const sizeStr = `${size.padStart(7)} kB`
                    const gzipStr = `${gzip.padStart(7)} kB`
                    console.log(`${paddedPath} â”‚ ${sizeStr} â”‚  ${gzipStr}`)
                  })
              }
            }

            // è¯¦ç»†ä¿¡æ¯è¾“å‡ºï¼ˆå¦‚æœå¯ç”¨è¯¦ç»†æ—¥å¿—ï¼‰
            if (VERBOSE) {
              if (loaded.length > 0 || skipped.length > 0) {
                const allFiles = [...loaded, ...skipped].sort((a, b) =>
                  a.route.localeCompare(b.route),
                )
                console.log('\nğŸ“Š è¯¦ç»†æ–‡ä»¶ä¿¡æ¯:')
                console.log(
                  'çŠ¶æ€         â”‚ è·¯å¾„                           â”‚ MIME ç±»å‹                      â”‚ åŸå›       ',
                )
                allFiles.forEach((file) => {
                  const isPreloaded = loaded.includes(file)
                  const status = isPreloaded ? 'å†…å­˜' : 'æŒ‰éœ€'
                  const reason =
                    !isPreloaded && file.size > MAX_PRELOAD_BYTES
                      ? 'è¿‡å¤§'
                      : !isPreloaded
                        ? 'è¿‡æ»¤'
                        : 'é¢„åŠ è½½'
                  const route =
                    file.route.length > 30
                      ? file.route.substring(0, 27) + '...'
                      : file.route
                  console.log(
                    `${status.padEnd(12)} â”‚ ${route.padEnd(30)} â”‚ ${file.type.padEnd(28)} â”‚ ${reason.padEnd(10)}`,
                  )
                })
              } else {
                console.log('\nğŸ“Š æ— æ–‡ä»¶ä¿¡æ¯å¯æ˜¾ç¤º')
              }
            }

            // æ–‡ä»¶åˆ—è¡¨è¾“å‡ºå®Œæ¯•åæ‰“å°æ€»ç»“
            console.log() // ç©ºè¡Œé—´éš”
            if (loaded.length > 0) {
              log.success(
                `å·²æˆåŠŸé¢„åŠ è½½ ${String(loaded.length)} ä¸ªæ–‡ä»¶ï¼Œåˆè®¡ ${(totalPreloadedBytes / 1024 / 1024).toFixed(2)} MB åˆ°å†…å­˜`,
              )
            } else {
              log.info('æ— æ–‡ä»¶é¢„åŠ è½½åˆ°å†…å­˜')
            }

            if (skipped.length > 0) {
              const tooLarge = skipped.filter((f) => f.size > MAX_PRELOAD_BYTES).length
              const filtered = skipped.length - tooLarge
              log.info(
                `${String(skipped.length)} ä¸ªæ–‡ä»¶æŒ‰éœ€åŠ è½½ï¼ˆ${String(tooLarge)} ä¸ªè¿‡å¤§ï¼Œ${String(filtered)} ä¸ªè¢«è¿‡æ»¤ï¼‰`,
              )
            }
          } catch (error) {
            log.error(
              `åŠ è½½é™æ€æ–‡ä»¶å¤±è´¥ ${clientDirectory}: ${String(error)}`,
            )
          }

          return { routes, loaded, skipped }
        }

        /**
        * åˆå§‹åŒ–æœåŠ¡å™¨ä¸»å‡½æ•°
        */
        async function initializeServer() {
          log.header('å¯åŠ¨ç”Ÿäº§æœåŠ¡å™¨')

          // åŠ è½½ TanStack Start æœåŠ¡å™¨å¤„ç†å™¨
          let handler: { fetch: (request: Request) => Response | Promise<Response> }
          try {
            const serverModule = (await import(SERVER_ENTRY_POINT)) as {
              default: { fetch: (request: Request) => Response | Promise<Response> }
            }
            handler = serverModule.default
            log.success('TanStack Start åº”ç”¨å¤„ç†å™¨åˆå§‹åŒ–æˆåŠŸ')
          } catch (error) {
            log.error(`åŠ è½½æœåŠ¡å™¨å¤„ç†å™¨å¤±è´¥: ${String(error)}`)
            process.exit(1)
          }

          // æ„å»ºæ”¯æŒæ™ºèƒ½é¢„åŠ è½½çš„é™æ€è·¯ç”±
          const { routes } = await initializeStaticRoutes(CLIENT_DIRECTORY)

          // åˆ›å»º Bun æœåŠ¡å™¨
          const server = Bun.serve({
            port: SERVER_PORT,

            routes: {
              // æä¾›é™æ€èµ„æº (é¢„åŠ è½½æˆ–æŒ‰éœ€)
              ...routes,

              // æ‰€æœ‰å…¶ä»–è¯·æ±‚äº¤ç”± TanStack Start å¤„ç†å™¨
              '/*': (req: Request) => {
                try {
                  return handler.fetch(req)
                } catch (error) {
                  log.error(`æœåŠ¡å™¨å¤„ç†é”™è¯¯: ${String(error)}`)
                  return new Response('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯', { status: 500 })
                }
              },
            },

            // å…¨å±€é”™è¯¯å¤„ç†
            error(error) {
              log.error(
                `æœåŠ¡å™¨æœªæ•è·é”™è¯¯: ${error instanceof Error ? error.message : String(error)}`,
              )
              return new Response('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯', { status: 500 })
            },
          })

          log.success(`æœåŠ¡å™¨å·²å¯åŠ¨ï¼Œç›‘å¬åœ°å€ï¼šhttp://localhost:${String(server.port)}`)
        }

        // å¯åŠ¨æœåŠ¡å™¨
        initializeServer().catch((error: unknown) => {
          log.error(`å¯åŠ¨æœåŠ¡å™¨å¤±è´¥: ${String(error)}`)
          process.exit(1)
        })
        ```

      </Step>
      <Step title="æ›´æ–° package.json è„šæœ¬">
        æ·»åŠ  `start` è„šæœ¬ä»¥è¿è¡Œè‡ªå®šä¹‰æœåŠ¡å™¨ï¼š

        ```json package.json icon="file-json"
        {
          "scripts": {
            "build": "bun --bun vite build",
            "start": "bun run server.ts" // [!code ++]
          }
        }
        ```

      </Step>
      <Step title="æ„å»ºå¹¶è¿è¡Œ">
        æ„å»ºåº”ç”¨å¹¶å¯åŠ¨æœåŠ¡å™¨ï¼š

        ```sh terminal icon="terminal"
        bun run build
        bun run start
        ```

        æœåŠ¡å™¨é»˜è®¤ç›‘å¬ 3000 ç«¯å£ï¼Œå¯é€šè¿‡ `PORT` ç¯å¢ƒå˜é‡é…ç½®ã€‚

      </Step>
    </Steps>

  </Tab>
</Tabs>

<Columns cols={3}>
  <Card title="Vercel" href="/guides/deployment/vercel" icon="/icons/ecosystem/vercel.svg">
    åœ¨ Vercel ä¸Šéƒ¨ç½²
  </Card>
  <Card title="Render" href="/guides/deployment/render" icon="/icons/ecosystem/render.svg">
    åœ¨ Render ä¸Šéƒ¨ç½²
  </Card>
  <Card title="Railway" href="/guides/deployment/railway" icon="/icons/ecosystem/railway.svg">
    åœ¨ Railway ä¸Šéƒ¨ç½²
  </Card>
  <Card title="DigitalOcean" href="/guides/deployment/digital-ocean" icon="/icons/ecosystem/digitalocean.svg">
    åœ¨ DigitalOcean ä¸Šéƒ¨ç½²
  </Card>
  <Card title="AWS Lambda" href="/guides/deployment/aws-lambda" icon="/icons/ecosystem/aws.svg">
    åœ¨ AWS Lambda ä¸Šéƒ¨ç½²
  </Card>
  <Card title="Google Cloud Run" href="/guides/deployment/google-cloud-run" icon="/icons/ecosystem/gcp.svg">
    åœ¨ Google Cloud Run ä¸Šéƒ¨ç½²
  </Card>
</Columns>

---

## æ¨¡æ¿

<Columns cols={2}>
  <Card
    title="ä½¿ç”¨ Tanstack + Bun çš„å¾…åŠåº”ç”¨"
    img="/images/templates/bun-tanstack-todo.png"
    href="https://github.com/bun-templates/bun-tanstack-todo"
    arrow="true"
    cta="æŸ¥çœ‹æ¨¡æ¿"
  >
    ä¸€ä¸ªä½¿ç”¨ Bunã€TanStack Start å’Œ PostgreSQL æ„å»ºçš„å¾…åŠäº‹é¡¹åº”ç”¨ã€‚
  </Card>
  <Card
    title="Bun + TanStack Start åº”ç”¨"
    img="/images/templates/bun-tanstack-basic.png"
    href="https://github.com/bun-templates/bun-tanstack-basic"
    arrow="true"
    cta="æŸ¥çœ‹æ¨¡æ¿"
  >
    ä¸€ä¸ªä½¿ç”¨ Bun çš„ SSR å’ŒåŸºäºæ–‡ä»¶è·¯ç”±çš„ TanStack Start æ¨¡æ¿ã€‚
  </Card>
  <Card
    title="åŸºç¡€ Bun + Tanstack å¯åŠ¨å™¨"
    img="/images/templates/bun-tanstack-start.png"
    href="https://github.com/bun-templates/bun-tanstack-start"
    arrow="true"
    cta="æŸ¥çœ‹æ¨¡æ¿"
  >
    åŸºç¡€çš„ TanStack å¯åŠ¨æ¨¡æ¿ï¼Œä½¿ç”¨ Bun è¿è¡Œæ—¶å’Œ Bun çš„æ–‡ä»¶ APIsã€‚
  </Card>
</Columns>

---

[â†’ æŸ¥çœ‹ TanStack Start å®˜æ–¹æ–‡æ¡£](https://tanstack.com/start/latest/docs/framework/react/guide/hosting) è·å–æ›´å¤šå…³äºéƒ¨ç½²æ‰˜ç®¡çš„ä¿¡æ¯ã€‚
