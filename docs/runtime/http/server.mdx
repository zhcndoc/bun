---
title: 服务器
description: 使用 `Bun.serve` 在 Bun 中启动高性能 HTTP 服务器
---

## 基本设置

```ts title="index.ts" icon="/icons/typescript.svg"
const server = Bun.serve({
  // `routes` 需要 Bun v1.2.3+
  routes: {
    // 静态路由
    "/api/status": new Response("OK"),

    // 动态路由
    "/users/:id": req => {
      return new Response(`Hello User ${req.params.id}!`);
    },

    // 按 HTTP 方法处理
    "/api/posts": {
      GET: () => new Response("List posts"),
      POST: async req => {
        const body = await req.json();
        return Response.json({ created: true, ...body });
      },
    },

    // 通配符路由，匹配所有以 "/api/" 开头且未被其他路由匹配的请求
    "/api/*": Response.json({ message: "Not found" }, { status: 404 }),

    // 从 /blog/hello 重定向到 /blog/hello/world
    "/blog/hello": Response.redirect("/blog/hello/world"),

    // 懒加载文件并提供服务
    "/favicon.ico": Bun.file("./favicon.ico"),
  },

  // （可选）未匹配路由的回退处理：
  // 如果 Bun 版本低于 1.2.3，则需要
  fetch(req) {
    return new Response("Not Found", { status: 404 });
  },
});

console.log(`Server running at ${server.url}`);
```

---

## HTML 导入

Bun 支持直接将 HTML 文件导入服务器代码，实现全栈应用，包含服务器端和客户端代码。HTML 导入有两种模式：

**开发模式 (`bun --hot`)：** 资源在运行时按需打包，支持热模块替换（HMR），实现快速迭代开发。当你更改前端代码时，浏览器会自动更新，无需完全刷新页面。

**生产模式 (`bun build`)：** 使用 `bun build --target=bun` 构建时，`import index from "./index.html"` 会解析为预构建的清单对象，包含所有打包好的客户端资源。`Bun.serve` 使用此清单提供优化过的资源，零运行时打包开销，非常适合生产环境部署。

```ts
import myReactSinglePageApp from "./index.html";

Bun.serve({
  routes: {
    "/": myReactSinglePageApp,
  },
});
```

HTML 导入不仅仅提供 HTML，它是一个完整的前端打包器、转译器和工具包，使用 Bun 的 [bundler](/bundler)、JavaScript 转译器和 CSS 解析器构建。你可以用它搭建带有 React、TypeScript、Tailwind CSS 等的全功能前端。

完整的使用 HTML 导入构建全栈应用指南，包括详细示例和最佳实践，请参见 [/docs/bundler/fullstack](/bundler/fullstack)。

---

## 配置

### 更改 `port` 和 `hostname`

要配置服务器监听的端口和主机名，在选项对象中设置 `port` 和 `hostname`。

```ts
Bun.serve({
  port: 8080, // 默认为 $BUN_PORT, $PORT, $NODE_PORT，否则为 3000 // [!code ++]
  hostname: "mydomain.com", // 默认为 "0.0.0.0" // [!code ++]
  fetch(req) {
    return new Response("404!");
  },
});
```

设置 `port` 为 `0` 来随机选择一个可用端口。

```ts
const server = Bun.serve({
  port: 0, // 随机端口 // [!code ++]
  fetch(req) {
    return new Response("404!");
  },
});

// server.port 是随机选择的端口
console.log(server.port);
```

你可以通过访问服务器对象的 `port` 属性或 `url` 属性来查看选中的端口。

```ts
console.log(server.port); // 3000
console.log(server.url); // http://localhost:3000
```

### 配置默认端口

Bun 支持多种选项和环境变量来配置默认端口。默认端口在未设置 `port` 选项时使用。

- `--port` 命令行参数

```sh
bun --port=4002 server.ts
```

- `BUN_PORT` 环境变量

```sh
BUN_PORT=4002 bun server.ts
```

- `PORT` 环境变量

```sh terminal icon="terminal"
PORT=4002 bun server.ts
```

- `NODE_PORT` 环境变量

```sh terminal icon="terminal"
NODE_PORT=4002 bun server.ts
```

---

## Unix 域套接字

要监听 [Unix 域套接字](https://zh.wikipedia.org/wiki/Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%90)，请传入 `unix` 选项并指定套接字路径。

```ts
Bun.serve({
  unix: "/tmp/my-socket.sock", // 套接字路径
  fetch(req) {
    return new Response(`404!`);
  },
});
```

### 抽象命名空间套接字

Bun 支持 Linux 抽象命名空间套接字。使用抽象命名空间套接字时，在 `unix` 路径前加前缀空字节（`\0`）。

```ts
Bun.serve({
  unix: "\0my-abstract-socket", // 抽象命名空间套接字
  fetch(req) {
    return new Response(`404!`);
  },
});
```

与 Unix 域套接字不同，抽象命名空间套接字不绑定到文件系统，并且在最后一个引用关闭时会自动删除。

---

## idleTimeout

通过在 `Bun.serve` 中设置 `idleTimeout` 字段来配置空闲超时时间。

```ts
Bun.serve({
  // 10秒：
  idleTimeout: 10,

  fetch(req) {
    return new Response("Bun!");
  },
});
```

这是服务器关闭连接之前，连接允许空闲的最长时间（秒）。没有数据发送或接收即视为空闲。

---

## export default 语法

到目前为止，页面上的示例均使用显式的 `Bun.serve` API。Bun 还支持另一种写法。

```ts server.ts
import type { Serve } from "bun";

export default {
  fetch(req) {
    return new Response("Bun!");
  },
} satisfies Serve.Options<undefined>;
```

类型参数 `<undefined>` 表示 WebSocket 数据 —— 如果你添加了带有自定义数据的 `websocket` 处理器，通过 `server.upgrade(req, { data: ... })` 附加数据，则将 `undefined` 替换为你的数据类型。

无需调用 `Bun.serve`，直接导出服务器选项。这文件可直接运行；当 Bun 看到存在一个含有 `fetch` 处理器的 `default` 导出时，会自动传入 `Bun.serve`。

---

## 热路由重载

使用 `server.reload()` 无需重启服务器即可更新路由：

```ts
const server = Bun.serve({
  routes: {
    "/api/version": () => Response.json({ version: "1.0.0" }),
  },
});

// 部署新路由无停机
server.reload({
  routes: {
    "/api/version": () => Response.json({ version: "2.0.0" }),
  },
});
```

---

## 服务器生命周期方法

### `server.stop()`

停止服务器接受新连接：

```ts
const server = Bun.serve({
  fetch(req) {
    return new Response("Hello!");
  },
});

// 优雅停止服务器（等待正在进行的请求完成）
await server.stop();

// 强制停止并关闭所有活跃连接
await server.stop(true);
```

默认情况下，`stop()` 会允许正在进行的请求和 WebSocket 连接完成。传入 `true` 会立即终止所有连接。

### `server.ref()` 和 `server.unref()`

控制服务器是否保持 Bun 进程存活：

```ts
// 如果服务器是唯一运行的东西，不阻止进程退出
server.unref();

// 恢复默认行为 - 保持进程存活
server.ref();
```

### `server.reload()`

无需重启即可更新服务器处理器：

```ts
const server = Bun.serve({
  routes: {
    "/api/version": Response.json({ version: "v1" }),
  },
  fetch(req) {
    return new Response("v1");
  },
});

// 更新为新处理器
server.reload({
  routes: {
    "/api/version": Response.json({ version: "v2" }),
  },
  fetch(req) {
    return new Response("v2");
  },
});
```

此方法适用于开发和热重载。仅允许更新 `fetch`、`error` 和 `routes`。

---

## 每请求控制

### `server.timeout(Request, seconds)`

为单个请求设置自定义空闲超时：

```ts
const server = Bun.serve({
  async fetch(req, server) {
    // 设置此请求的超时为 60 秒
    server.timeout(req, 60);

    // 如果请求体发送超过 60 秒，则请求将被中止
    await req.text();

    return new Response("Done!");
  },
});
```

传入 `0` 可禁用该请求的超时。

### `server.requestIP(Request)`

获取客户端 IP 和端口信息：

```ts
const server = Bun.serve({
  fetch(req, server) {
    const address = server.requestIP(req);
    if (address) {
      return new Response(`Client IP: ${address.address}, Port: ${address.port}`);
    }
    return new Response("Unknown client");
  },
});
```

对于已关闭请求或 Unix 域套接字返回 `null`。

---

## 服务器指标

### `server.pendingRequests` 和 `server.pendingWebSockets`

使用内置计数器监控服务器活动：

```ts
const server = Bun.serve({
  fetch(req, server) {
    return new Response(
      `Active requests: ${server.pendingRequests}\n` + `Active WebSockets: ${server.pendingWebSockets}`,
    );
  },
});
```

### `server.subscriberCount(topic)`

获取某个 WebSocket 主题的订阅者数量：

```ts
const server = Bun.serve({
  fetch(req, server) {
    const chatUsers = server.subscriberCount("chat");
    return new Response(`${chatUsers} users in chat`);
  },
  websocket: {
    message(ws) {
      ws.subscribe("chat");
    },
  },
});
```

---

## 性能基准

以下是 Bun 和 Node.js 实现的简单 HTTP 服务器，每个请求都响应 `Bun!`。

```ts Bun
Bun.serve({
  fetch(req: Request) {
    return new Response("Bun!");
  },
  port: 3000,
});
```

```ts
require("http")
  .createServer((req, res) => res.end("Bun!"))
  .listen(8080);
```

Bun.serve 服务器在 Linux 上每秒可处理请求数大约是 Node.js 的 2.5 倍。

| 运行环境 | 每秒请求数     |
| -------- | -------------- |
| Node 16  | ~64,000        |
| Bun      | ~160,000       |

<Frame>
  ![image](https://user-images.githubusercontent.com/709451/162389032-fc302444-9d03-46be-ba87-c12bd8ce89a0.png)
</Frame>

---

## 实例示范：REST API

这是使用 Bun 路由的基本数据库驱动 REST API，无任何依赖：

<CodeGroup>

```ts server.ts expandable icon="file-code"
import type { Post } from "./types.ts";
import { Database } from "bun:sqlite";

const db = new Database("posts.db");
db.exec(`
  CREATE TABLE IF NOT EXISTS posts (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TEXT NOT NULL
  )
`);

Bun.serve({
  routes: {
    // 列出帖子
    "/api/posts": {
      GET: () => {
        const posts = db.query("SELECT * FROM posts").all();
        return Response.json(posts);
      },

      // 创建帖子
      POST: async req => {
        const post: Omit<Post, "id" | "created_at"> = await req.json();
        const id = crypto.randomUUID();

        db.query(
          `INSERT INTO posts (id, title, content, created_at)
           VALUES (?, ?, ?, ?)`,
        ).run(id, post.title, post.content, new Date().toISOString());

        return Response.json({ id, ...post }, { status: 201 });
      },
    },

    // 根据 ID 获取帖子
    "/api/posts/:id": req => {
      const post = db.query("SELECT * FROM posts WHERE id = ?").get(req.params.id);

      if (!post) {
        return new Response("Not Found", { status: 404 });
      }

      return Response.json(post);
    },
  },

  error(error) {
    console.error(error);
    return new Response("Internal Server Error", { status: 500 });
  },
});
```

```ts types.ts icon="/icons/typescript.svg"
export interface Post {
  id: string;
  title: string;
  content: string;
  created_at: string;
}
```

</CodeGroup>

---

## 参考

```ts expandable See TypeScript Definitions
interface Server extends Disposable {
  /**
   * 停止服务器接受新连接。
   * @param closeActiveConnections 若为 true，立即终止所有连接
   * @returns 服务器停止时解析的 Promise
   */
  stop(closeActiveConnections?: boolean): Promise<void>;

  /**
   * 更新处理器，无需重启服务器。
   * 仅可更新 fetch 和 error 处理器。
   */
  reload(options: Serve): void;

  /**
   * 向运行中的服务器发起请求。
   * 用于测试或内部路由。
   */
  fetch(request: Request | string): Response | Promise<Response>;

  /**
   * 将 HTTP 请求升级为 WebSocket 连接。
   * @returns 升级成功返回 true，失败返回 false
   */
  upgrade<T = undefined>(
    request: Request,
    options?: {
      headers?: Bun.HeadersInit;
      data?: T;
    },
  ): boolean;

  /**
   * 向所有订阅某主题的 WebSocket 客户端发布消息。
   * @returns 已发送字节数，若丢弃返回 0，若施加背压返回 -1
   */
  publish(
    topic: string,
    data: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
    compress?: boolean,
  ): ServerWebSocketSendStatus;

  /**
   * 获取某主题订阅的 WebSocket 客户端数量。
   */
  subscriberCount(topic: string): number;

  /**
   * 获取客户端 IP 地址和端口。
   * @returns 关闭请求或 Unix 套接字返回 null
   */
  requestIP(request: Request): SocketAddress | null;

  /**
   * 为请求设置自定义空闲超时。
   * @param seconds 超时时间（秒），传 0 禁用
   */
  timeout(request: Request, seconds: number): void;

  /**
   * 在服务器运行时保持进程存活。
   */
  ref(): void;

  /**
   * 允许服务器成为唯一运行时进程退出。
   */
  unref(): void;

  /** 当前正在处理的 HTTP 请求数量 */
  readonly pendingRequests: number;

  /** 当前活跃的 WebSocket 连接数 */
  readonly pendingWebSockets: number;

  /** 服务器完整 URL，包括协议、主机名和端口 */
  readonly url: URL;

  /** 服务器监听的端口 */
  readonly port: number;

  /** 服务器绑定的主机名 */
  readonly hostname: string;

  /** 服务器是否处于开发模式 */
  readonly development: boolean;

  /** 服务器实例 ID */
  readonly id: string;
}

interface WebSocketHandler<T = undefined> {
  /** 最大 WebSocket 消息大小，单位字节 */
  maxPayloadLength?: number;

  /** 应用背压前排队消息的字节数 */
  backpressureLimit?: number;

  /** 达到背压限制时是否关闭连接 */
  closeOnBackpressureLimit?: boolean;

  /** 背压解除时调用 */
  drain?(ws: ServerWebSocket<T>): void | Promise<void>;

  /** 空闲超时时间，单位秒 */
  idleTimeout?: number;

  /** 启用 per-message deflate 压缩 */
  perMessageDeflate?:
    | boolean
    | {
        compress?: WebSocketCompressor | boolean;
        decompress?: WebSocketCompressor | boolean;
      };

  /** 发送 Ping 帧以保持连接活跃 */
  sendPings?: boolean;

  /** 是否服务器会接收自身发布的消息 */
  publishToSelf?: boolean;

  /** 连接打开时调用 */
  open?(ws: ServerWebSocket<T>): void | Promise<void>;

  /** 收到消息时调用 */
  message(ws: ServerWebSocket<T>, message: string | Buffer): void | Promise<void>;

  /** 连接关闭时调用 */
  close?(ws: ServerWebSocket<T>, code: number, reason: string): void | Promise<void>;

  /** 收到 Ping 帧时调用 */
  ping?(ws: ServerWebSocket<T>, data: Buffer): void | Promise<void>;

  /** 收到 Pong 帧时调用 */
  pong?(ws: ServerWebSocket<T>, data: Buffer): void | Promise<void>;
}

interface TLSOptions {
  /** 证书颁发机构链 */
  ca?: string | Buffer | BunFile | Array<string | Buffer | BunFile>;

  /** 服务器证书 */
  cert?: string | Buffer | BunFile | Array<string | Buffer | BunFile>;

  /** DH 参数文件路径 */
  dhParamsFile?: string;

  /** 私钥 */
  key?: string | Buffer | BunFile | Array<string | Buffer | BunFile>;

  /** 减少 TLS 内存使用 */
  lowMemoryMode?: boolean;

  /** 私钥密码 */
  passphrase?: string;

  /** OpenSSL 选项标志 */
  secureOptions?: number;

  /** SNI 服务器名称 */
  serverName?: string;
}
```